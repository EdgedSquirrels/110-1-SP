<!--
###### tags: `SP`
---
-->
# SP 程式 hw1
Homework spec: https://hackmd.io/3noAEKDJR8Ke8Ak84F4vyw
## File structure
```
src/
├── Makefile
├── server.c
│ 
└── executables generated by server.c
    ├── server
    └── client
```

# The main concept:
The code below briefly show the workflow, it does not follow the real c syntax. Instead, this workflow is intended to focus on the time to handle locks and I/O.

> **Strategy of Locking**
> 
> 1. 
>   |  | Write server | Read server |
>   | -------- | -------- | -------- |
>   | **Read** | F_RDLCK    | F_RDLCK     |
>   | **Write**| F_WRLCK     | -    |
>   
> > **Problem:**
> > When the write server starts to set lock on the database for getting the preference order, it means that the write server is going to modify later **without** considering lock blocking by other process. To prevent other write processes from getting the permission, it would be a nice choice to **set the write lock at the time of reading**, to signal other processes.
> 2. 
>   |  | Write server | Read server |
>   | -------- | -------- | -------- |
>   | **Read** | **F_WRLCK** till end| F_RDLCK     |
>   | **Write**| F_WRLCK     | -    |
>   
> > **Problem:**
> > If an id record is being read by a read server exatly at the time a write server want to read, the write server lost the permission the access the database, but at that very time no other user is ordering, violating the rule that `A write user will be output locked only when no other user is using the identical ID for ordering`. Thankfully, we do not need to take race condition into consideration. It's not necessary to solve the situation.
```c
int main() {
    // init process...
    init_server();
    db_fd = open("recordCard", O_RDWR);
    ids_avail[25] = {1}; // available ids for lock check
    while true :
        // poll each time to check if any fd is ready
        poll(fds);
        for each available fd:
            if fd is the listening port:
                // handle new connection
                conn_fd = accept();
                write(conn_fd, "request for id");
                req[conn_fd].stage = 0;
                
            elif fd is client:
                // handle existing connection input
                string s = hadle_read(fd);
                if req[fd].stage == 0:
                    // verify read id
                    if s is invalid:
                        handle_err(fd);
                        close_connection(fd);
                        continue;
                    id = atoi(s);
                    lock_type = F_RDLCK
                    #ifdef WRITE_SERVER
                        lock_type = F_WRLCK
                    #endif
                    if ids_avail[id] and set_write_lock(db_fd, id, lock_type):
                        ids_avail[id] = 0;
                        data = get_info(db_fd, id);
                        write(fd, "Your preference", data);
                        
                        #ifdef WRITE_SERVER
                            write(fd, "request for new preference");
                            req[fd].stage = 1;
                        #elif READ_SERVER
                            unlock(db_fd, id);
                            ids_avil[id] = 1;
                            handle_end(fd);
                            continue;
                        #endif
                    else:
                        handle_lcked(fd);
                        continue;
                    
                elif req[fd].stage == 1:
                    // handle read preference
                    if s is invalid:
                        unlock(db_fd, id);
                        handle_err(fd);
                    else:
                        write(db_fd, "New preference");
                        write(fd, "New preference");
                        ids_avail[id] = 1;
                    unlock(db_fd, id);
                    ids_avail[id] = 1;
                    
}
```
